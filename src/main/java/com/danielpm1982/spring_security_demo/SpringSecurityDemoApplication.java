package com.danielpm1982.spring_security_demo;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringSecurityDemoApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringSecurityDemoApplication.class, args);
	}
}

/*
After building and starting this application:
-> you can view and test all endpoints at:
http://localhost:8080/swagger
or
http://localhost:8080/v3/api-docs

-> you can view the H2 console at:
http://localhost:8080/h2-console
*/

/* Official documentation at:
https://docs.spring.io/spring-security/reference/index.html
*/

/*
Summary of this app flux:
1) This is a CRUD REST API where you can sign up and login users, so that these can access secured endpoints from this same
application. The users are persisted using JPA into an H2 DBMS DB, into a local file (auth_db.mv.db) located at this app source
folder. Passwords are encrypted using BCrypt before the user data is sent to the DB;
2) As long as the user is already persisted at this app DB, he may now log in. In the case of a REST API, and differently from a
frontend or MVC app, this means the user first may send a log in request, which, if succeeds, returns a JWT token (with a certain
expiration time) as a response (generated by the TokenManager). Then, the user may send ANOTHER request, to any secured endpoint,
having that provided JWT token set at its header, as the Authorization header prop. The value of this prop is "Bearer " plus the
JWT token provided (basically a hash value);
3) The secured endpoints that demand authentication, as well as those which don't, are defined and matched at the WebSecurityConfig
bean. This bean identifies internally which requests are gonna demand previous authentication, in order to be accepted by the
Controllers, through a series of Filters and a FilterChain. We then define a custom filter of our own, MyAuthenticationFilter,
which is going to be responsible for registering our valid users in case they manage to authenticate successfully. At the
MyAuthenticationFilter class, we call the TokenManager to decode and validate the JWT token from each current request, having
returned an Authentication object. This object is then registered at the SecurityContextHolder, clearing the way, at the flux,for
that user request, along the security filter chain... that is, letting the request finally get to the Controller method mapped to
the requested endpoint. As such, letting the user access the requested secured resource. For each request, a new validation of the
token is done. If the token expires, the user must log in again, for getting a new valid token;
4) In case the request header token is not valid, an Exception is thrown within the TokenManager, ultimately being displayed to the
user, as an Http response, showing the error message, along with the invalid token hash;
5) All dependent classes must be injected and registered at the filter chain configuration, at the WebSecurityConfig bean. Including
the MyAuthenticationFilter and the MyJwtAuthenticationEntryPoint (this latter helps to build the validation error response to the
user). There are different ways of doing this filter chain configuration, especially in the case of exception handling. You might
need to add your custom authentication filter in different positions, at the filter chain, depending on what dependent classes you
are using.
6) At least two versions of this same app, specifically regarding filter chain exception handling, when validating tokens, are
presented at this project. See the README.md for the respective links of the different version commits. This sample project may be
reused for implementing any other REST Web Service app, only adding the other classes to it (business logic). In case you wanna
implement an MVC or frontend app, the strategies would be different, regarding Spring Security... basically considering how you would
store the session state of the user, then. At REST apps, though, there's no such a thing, all Http requests are stateless, and the
identification of the user, for authentication and authorization, must be done through JWT tokens (with or without OAuth).
 */
